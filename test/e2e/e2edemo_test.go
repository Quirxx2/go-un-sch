//go:build e2e

package e2e

import (
	"bytes"
	"context"
	"encoding/json"
	"io"
	"log"
	"net/http"
	"os"
	"strconv"
	"sync"
	"testing"

	"github.com/stretchr/testify/assert"
	"gitlab.com/DzmitryYafremenka/golang-united-school-certs/api"
	"google.golang.org/grpc"
	"google.golang.org/grpc/credentials/insecure"
)

func Test_Demo(t *testing.T) {
	host := "localhost:8080"
	httpHost := "http://" + host

	ctx := context.Background()
	conn, err := grpc.DialContext(ctx, host, grpc.WithTransportCredentials(insecure.NewCredentials()))
	if err != nil {
		log.Fatal("failed to connect:", err)
	}
	defer conn.Close()

	client := api.NewCertsServiceClient(conn)

	// test working dir points to package dir
	err = os.Chdir("../..")
	templatePath := "./test/testdata/e2e/demo/index.html"
	if err != nil {
		assert.FailNow(t, "failed to change working directory:", err)
	}

	template, err := os.ReadFile(templatePath)
	if err != nil {
		assert.FailNow(t, "failed to read template file:", err)
	}

	templateName := "Example"
	_, err = client.AddTemplate(ctx, &api.AddTemplateRequest{Name: templateName, Content: string(template)})
	if !assert.NoError(t, err) {
		assert.FailNow(t, "failed to add template:", err)
	}
	t.Log("Add template through gRPC with name:", templateName)

	// Add certificates through gRPC
	ids := []string{}
	wg := new(sync.WaitGroup)
	mu := new(sync.Mutex)
	for i := 1; i <= 4; i++ {
		wg.Add(1)
		go func(i int) {
			defer wg.Done()
			r, err := client.AddCertificate(ctx, &api.AddCertificateRequest{
				TemplateName: templateName,
				Student:      "Student " + strconv.Itoa(i),
				IssueDate:    strconv.Itoa(i) + " December 1999",
				Course:       "Test Course",
				Mentors:      "Test Mentor One, Test Mentor Two",
			})
			if !assert.NoError(t, err) {
				assert.FailNow(t, "failed to add certificate:", err)
			}
			mu.Lock()
			ids = append(ids, r.GetId())
			mu.Unlock()
			t.Log("Add certificates through gRPC with id:", r.GetId())
		}(i)
	}
	wg.Wait()

	// Add certificates through REST
	restIds := []string{}
	for i := 5; i <= 8; i++ {
		wg.Add(1)
		go func(i int) {
			defer wg.Done()
			reqBody, err := json.Marshal(map[string]string{
				"templateName": templateName,
				"student":      "Student " + strconv.Itoa(i),
				"issueDate":    strconv.Itoa(i) + " December 2000",
				"course":       "Test Course",
				"mentors":      "Test Mentor One, Test Mentor Two",
			})
			if err != nil {
				assert.FailNow(t, "failed to compose REST request body: ", err)
			}

			resp, err := http.Post(httpHost+"/certificate", "application/json", bytes.NewBuffer(reqBody))
			if !assert.NoError(t, err) || !assert.Equal(t, http.StatusOK, resp.StatusCode) {
				assert.FailNow(t, "failed to add certificate:", err)
			}

			body, err := io.ReadAll(resp.Body)
			if err != nil {
				assert.FailNow(t, "failed to read response body:", err)
			}

			m := make(map[string]string)
			err = json.Unmarshal(body, &m)
			if err != nil {
				assert.FailNow(t, "failed to unmarshal response:", err)
			}

			id, ok := m["id"]
			assert.True(t, ok)

			mu.Lock()
			restIds = append(restIds, id)
			mu.Unlock()
			t.Log("Add certificates through REST with id:", id)
		}(i)
	}
	wg.Wait()

	// Get certificates PDF files through gRPC, generates PDF files if doesn't exists yet
	for _, id := range ids {
		wg.Add(1)
		go func(id string) {
			defer wg.Done()
			r, err := client.GetCertificate(ctx, &api.GetCertificateRequest{Id: id})
			if !assert.NoError(t, err) {
				assert.FailNow(t, "failed to get certificate:", err)
			}
			assert.NotEmpty(t, r.GetData())
			t.Log("Get PDF certificates file through gRPC with id:", id)
		}(id)
	}
	wg.Wait()

	// Get certificate links through gRPC, PDF files already exists
	t.Log("Links to PDF files already generated by previous GetCertificate calls:")
	for _, id := range ids {
		wg.Add(1)
		go func(id string) {
			defer wg.Done()
			r, err := client.GetCertificateLink(ctx, &api.GetCertificateLinkRequest{Id: id})
			if !assert.NoError(t, err) {
				assert.FailNow(t, "failed to get certificate link:", err)
			}
			assert.NotEmpty(t, r.GetLink())
			t.Log("Get certificate link through gRPC:", r.GetLink())
		}(id)
	}
	wg.Wait()

	// Get certificate links through REST, PDF files not generated yet
	t.Log("Links to PDF files not generated yet:")
	for _, id := range restIds {
		wg.Add(1)
		go func(id string) {
			defer wg.Done()
			resp, err := http.Get(httpHost + "/certificate/" + id + "/link")
			if !assert.NoError(t, err) || !assert.Equal(t, http.StatusOK, resp.StatusCode) {
				assert.FailNow(t, "failed to get certificate:", err)
			}

			body, err := io.ReadAll(resp.Body)
			if err != nil {
				assert.FailNow(t, "failed to read response body:", err)
			}

			m := make(map[string]string)
			err = json.Unmarshal(body, &m)
			if err != nil {
				assert.FailNow(t, "failed to unmarshal response:", err)
			}

			link, ok := m["link"]
			assert.True(t, ok)
			t.Log("Get certificate link through REST:", link)
		}(id)
	}
	wg.Wait()

}
